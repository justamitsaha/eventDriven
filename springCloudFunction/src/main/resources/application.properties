server.port=8081
#spring.cloud.stream.kafka.binder.broker= localhost:9092, localhost:9093, localhost:9094
spring.cloud.stream.kafka.binder.brokers=192.168.0.143:9092,192.168.0.143:9093,192.168.0.143:9094

spring.cloud.function.definition=smsConsumer;smsProducer;emailConsumer;emailProducer
# --- Bind input and output of sms function to Kafka ---
spring.cloud.stream.bindings.smsConsumer-in-0.destination=smsEvent
spring.cloud.stream.bindings.smsProducer-out-0.destination=smsEvent
# --- Bind input and output of email function to Kafka ---
spring.cloud.stream.bindings.emailConsumer-in-0.destination=emailEvent
spring.cloud.stream.bindings.emailProducer-out-0.destination=emailEvent

# Consumer group for email consumers
spring.cloud.stream.bindings.emailConsumer-in-0.group=email-consumer-group
spring.cloud.stream.bindings.smsConsumer-in-0.group=sms-consumer-group

# Enable partitioned consumption comment this if you are running single instance
spring.cloud.stream.bindings.emailConsumer-in-0.consumer.partitioned=true
spring.cloud.stream.bindings.smsConsumer-in-0.consumer.partitioned=true

# Partition count is 3, so messages will be routed by hash(key) % 3, Since we are handling key from code below is not necessary
#spring.cloud.stream.bindings.smsProducer-out-0.producer.partition-key-expression=payload.paymentUuid
#spring.cloud.stream.bindings.smsProducer-out-0.producer.partition-count=3


# Tell Stream to use JSON serialization
spring.cloud.stream.default.contentType=application/json

# Specific binding configs (optional, but explicit is better)
spring.cloud.stream.bindings.smsProducer-out-0.content-type=application/json
spring.cloud.stream.bindings.emailProducer-out-0.content-type=application/json
spring.cloud.stream.bindings.smsConsumer-in-0.content-type=application/json
spring.cloud.stream.bindings.emailConsumer-in-0.content-type=application/json



#springdoc.swagger-ui.path=/swagger-ui/index.html
#
#springdoc.show-actuator=true
#springdoc.webjars.prefix=
