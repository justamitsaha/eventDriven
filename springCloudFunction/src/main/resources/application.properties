server.port=8081
# Dev: verbose with method & line numbers, colored
logging.pattern.console = ${LOGPATTERN_CONSOLE:%green(%d{HH:mm:ss.SSS}) %blue(%-5level) %red([%thread]) %yellow(%class.%M:%L) - %msg%n}


# Prod: leaner, colored but no method/line
# logging.pattern.console = ${LOGPATTERN_CONSOLE:%green(%d{HH:mm:ss.SSS}) %blue(%-5level) %red([%thread]) %yellow(%logger{15}) - %msg%n}



#spring.cloud.stream.kafka.binder.broker= localhost:9092, localhost:9093, localhost:9094
spring.cloud.stream.kafka.binder.brokers=192.168.0.143:9092,192.168.0.143:9093,192.168.0.143:9094

#spring.cloud.function.definition=smsConsumer;smsProducer;emailConsumer;emailProducer;smsDlqConsumer
spring.cloud.function.definition=smsConsumer;emailConsumer;smsProducer;emailProducer;smsDlqConsumer


# --- Bind input and output of sms function to Kafka ---
spring.cloud.stream.bindings.smsConsumer-in-0.destination=smsEvent
spring.cloud.stream.bindings.smsProducer-out-0.destination=smsEvent
# --- Bind input and output of email function to Kafka ---
spring.cloud.stream.bindings.emailConsumer-in-0.destination=emailEvent
spring.cloud.stream.bindings.emailProducer-out-0.destination=emailEvent

# Consumer group for email consumers
spring.cloud.stream.bindings.emailConsumer-in-0.group=email-consumer-group
spring.cloud.stream.bindings.smsConsumer-in-0.group=sms-consumer-group

# Enable partitioned consumption comment this if you are running single instance
#spring.cloud.stream.bindings.emailConsumer-in-0.consumer.partitioned=true
#spring.cloud.stream.bindings.smsConsumer-in-0.consumer.partitioned=true

# Partition count is 3, so messages will be routed by hash(key) % 3,
# Since we are handling key from code below is not necessary
#spring.cloud.stream.bindings.smsProducer-out-0.producer.partition-key-expression=payload.paymentUuid
#spring.cloud.stream.bindings.smsProducer-out-0.producer.partition-count=3




# --- Enable DLT for this binding done only for sms topic---
spring.cloud.stream.kafka.bindings.smsConsumer-in-0.consumer.enable-dlq=true
spring.cloud.stream.kafka.bindings.smsConsumer-in-0.consumer.dlq-name=smsEvent.DLT
# Optional: control retries (default is infinite!)
spring.cloud.stream.kafka.bindings.smsConsumer-in-0.consumer.max-attempts=3
spring.cloud.stream.kafka.bindings.smsConsumer-in-0.consumer.back-off-initial-interval=1000
spring.cloud.stream.kafka.bindings.smsConsumer-in-0.consumer.back-off-multiplier=2.0
spring.cloud.stream.kafka.bindings.smsConsumer-in-0.consumer.back-off-max-interval=10000
# DLQ consumer
spring.cloud.stream.bindings.smsDlqConsumer-in-0.destination=smsEvent.DLT
spring.cloud.stream.bindings.smsDlqConsumer-in-0.group=sms-dlq-group



# Tell Stream to use JSON serialization
spring.cloud.stream.default.contentType=application/json

# Specific binding configs (optional, but explicit is better)
spring.cloud.stream.bindings.smsProducer-out-0.content-type=application/json
spring.cloud.stream.bindings.emailProducer-out-0.content-type=application/json
spring.cloud.stream.bindings.smsConsumer-in-0.content-type=application/json
spring.cloud.stream.bindings.emailConsumer-in-0.content-type=application/json



#springdoc.swagger-ui.path=/swagger-ui/index.html
#
#springdoc.show-actuator=true
#springdoc.webjars.prefix=
